/**
 * ----------------------------------------------------------
 * ULTIMATE ATTENDANCE MANAGER (v37 - MANUAL ENTRY + AUTOCOMPLETE)
 * ----------------------------------------------------------
 * NEW FEATURE:
 * - Manual Entry Tab: A form to type data easily.
 * - Reference Autocomplete: Suggests names from the sheet (Names & References)
 * while typing "Connected To" field.
 * ----------------------------------------------------------
 */

function onOpen() {
  try {
    SpreadsheetApp.getUi()
      .createMenu('Attendance Manager')
      .addItem('üöÄ Launch Attendance Sidebar', 'showSidebar')
      .addSeparator()
      .addItem('‚¨áÔ∏è Export Custom CSV', 'showExportSidebar')
      .addToUi();
  } catch (e) {
    console.log("UI not available: " + e.message);
  }
}

// --- 1. ATTENDANCE SIDEBAR ---
function showSidebar() {
  try {
    const html = HtmlService.createHtmlOutput(getHtml())
      .setTitle('Attendance Manager')
      .setWidth(420);
    SpreadsheetApp.getUi().showSidebar(html);
  } catch (e) {
    Logger.log("Error opening sidebar: " + e.message);
  }
}

// --- 2. EXPORT SIDEBAR ---
function showExportSidebar() {
  try {
    const html = HtmlService.createHtmlOutput(getExportHtml())
      .setTitle('Export to CSV')
      .setWidth(350);
    SpreadsheetApp.getUi().showSidebar(html);
  } catch (e) {
    Logger.log("Error opening export: " + e.message);
  }
}

/** HTML FOR ATTENDANCE SIDEBAR */
function getHtml() {
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <base target="_top">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
        <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
        <style>
          body { font-family: 'Inter', sans-serif; padding: 16px; background-color: #f8fafc; color: #334155; }
          h3 { margin: 0 0 12px 0; font-size: 16px; font-weight: 700; color: #0f172a; }
          .card { background: white; padding: 16px; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 16px; border: 1px solid #e2e8f0; }
          label { display: block; font-size: 11px; font-weight: 600; text-transform: uppercase; color: #64748b; margin-bottom: 6px; }
          textarea { width: 100%; height: 80px; padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px; font-family: monospace; font-size: 11px; resize: vertical; box-sizing: border-box; white-space: pre; overflow-x: auto; }
          textarea:focus { outline: none; border-color: #6366f1; ring: 2px solid #6366f1; }
          select, input { width: 100%; padding: 8px 10px; border: 1px solid #cbd5e1; border-radius: 8px; font-size: 13px; margin-bottom: 12px; box-sizing: border-box; }
          
          /* TABS */
          .tabs { display: flex; border-bottom: 1px solid #e2e8f0; margin-bottom: 12px; }
          .tab { padding: 8px 12px; cursor: pointer; font-size: 12px; font-weight: 600; color: #64748b; border-bottom: 2px solid transparent; }
          .tab.active { color: #4f46e5; border-bottom-color: #4f46e5; }
          
          .tab-content { display: none; }
          .tab-content.active { display: block; }

          /* BUTTONS */
          button.primary { background: #4f46e5; color: white; border: none; padding: 12px; border-radius: 8px; width: 100%; font-weight: 600; cursor: pointer; transition: all 0.2s; }
          button.primary:hover { background: #4338ca; }
          button.primary:disabled { background: #94a3b8; cursor: not-allowed; }
          
          button.secondary { background: #fff; color: #64748b; border: 1px solid #e2e8f0; font-size: 12px; padding: 8px; width: 100%; margin-top: 8px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
          button.secondary:hover { background: #f1f5f9; border-color: #94a3b8; color: #475569; }
          
          button.danger { background: #fff; color: #ef4444; border: 1px solid #fecaca; font-size: 12px; padding: 8px; width: 100%; margin-top: 5px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
          button.danger:hover { background: #fef2f2; border-color: #ef4444; }

          /* MAPPING */
          .map-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
          .map-label { font-size: 11px; width: 60px; flex-shrink: 0; font-weight: bold; }
          .map-select { margin-bottom: 0; font-size: 11px; }
          .add-btn { background: #f1f5f9; color: #334155; border: 1px dashed #cbd5e1; padding: 6px; width: 100%; text-align: center; border-radius: 6px; font-size: 11px; cursor: pointer; margin-top: 5px; }
          .add-btn:hover { background: #e2e8f0; }

          .status { margin-top: 12px; padding: 10px; border-radius: 8px; font-size: 12px; display: none; }
          .status.success { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
          .status.error { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }
          .refresh { float: right; color: #6366f1; font-size: 11px; cursor: pointer; text-decoration: none; }
          .or-divider { text-align: center; font-size: 10px; color: #94a3b8; margin: -5px 0 8px 0; font-weight: bold; }
        </style>
      </head>
      <body>
        <h3>Attendance Manager</h3>
        
        <div class="tabs">
          <div class="tab active" onclick="switchTab('paste')">Paste Data</div>
          <div class="tab" onclick="switchTab('manual')">Manual Entry</div>
        </div>

        <div class="card">
          
          <!-- TAB 1: PASTE DATA -->
          <div id="tab-paste" class="tab-content active">
            <label>Data Source (ID [Tab] Name...)</label>
            <input type="file" id="fileInput" accept=".csv, .xlsx, .xls" onchange="handleFile()">
            <div class="or-divider">OR PASTE</div>
            <textarea id="pasteArea" placeholder="101\n102  Rahul  98765"></textarea>
          </div>

          <!-- TAB 2: MANUAL ENTRY -->
          <div id="tab-manual" class="tab-content">
            <label>Add Single Entry</label>
            <input type="text" id="manualName" placeholder="Name or ID (Required)">
            <input type="text" id="manualInfo" placeholder="Mobile / Address (Optional)">
            
            <label>Connected To (Reference)</label>
            <input type="text" id="manualRef" list="refSuggestions" placeholder="Type to search name...">
            <datalist id="refSuggestions">
              <!-- Populated by GS -->
            </datalist>
            
            <button class="secondary" onclick="addToPasteArea()" style="margin-top:0; border-color:#6366f1; color:#6366f1;">
              + Add to Queue
            </button>
          </div>

        </div>

        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="margin:0">2. Map Your Data</label>
            <a class="refresh" onclick="loadHeaders()">Refresh Headers</a>
          </div>
          <div id="mappingContainer">
            <div style="text-align:center; padding:10px; color:#999;">Loading sheet headers...</div>
          </div>
          <div class="add-btn" onclick="addMappingRow()">+ Add Another Field</div>
        </div>

        <div class="card">
          <label>3. Date Column</label>
          <input type="date" id="dateInput">
          <select id="columnSelect">
            <option value="END">Create at the very end</option>
          </select>
        </div>

        <button class="primary" id="runBtn" onclick="runProcess()">Merge & Mark 'P'</button>
        <button class="secondary" id="dedupeBtn" onclick="dedupeInput()">Cleanup Input Box</button>
        <button class="danger" id="sheetDedupeBtn" onclick="runSheetDedupe()">‚ö† Remove Duplicates from Sheet</button>
        
        <div id="statusBox" class="status"></div>

        <script>
          let sheetHeaders = [];
          let cachedOptions = "";
          let mappingCount = 0;

          window.onload = function() {
            document.getElementById('dateInput').valueAsDate = new Date();
            loadHeaders();
            loadSuggestions(); // Load autocomplete data
          };

          function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if(tabName === 'paste') {
               document.querySelectorAll('.tab')[0].classList.add('active');
               document.getElementById('tab-paste').classList.add('active');
            } else {
               document.querySelectorAll('.tab')[1].classList.add('active');
               document.getElementById('tab-manual').classList.add('active');
            }
          }

          function loadHeaders() {
            google.script.run.withSuccessHandler(initUI).getSheetHeaders();
          }

          function loadSuggestions() {
            google.script.run.withSuccessHandler(fillDatalist).getReferenceSuggestions();
          }

          function fillDatalist(names) {
            const dl = document.getElementById('refSuggestions');
            dl.innerHTML = '';
            names.forEach(name => {
              const opt = document.createElement('option');
              opt.value = name;
              dl.appendChild(opt);
            });
          }

          function addToPasteArea() {
            const name = document.getElementById('manualName').value.trim();
            const info = document.getElementById('manualInfo').value.trim();
            const ref = document.getElementById('manualRef').value.trim();
            
            if(!name) return alert("Name/ID is required");
            
            // Construct Tab Separated Line
            // Logic: Name [Tab] Info [Tab] Reference
            // This assumes user maps 1st=Name, 2nd=Mobile, 3rd=Reference
            let line = name;
            if(info) line += '\\t' + info;
            else line += '\\t'; // Empty slot if info missing but ref exists
            
            if(ref) line += '\\t' + ref;
            
            const pasteArea = document.getElementById('pasteArea');
            const currentVal = pasteArea.value;
            pasteArea.value = currentVal ? currentVal + '\\n' + line : line;
            
            // Clear inputs
            document.getElementById('manualName').value = '';
            document.getElementById('manualInfo').value = '';
            document.getElementById('manualRef').value = '';
            
            // Switch back to see result
            switchTab('paste');
            showStatus("Added to queue. Please check Mapping below matches your fields.", "success");
          }

          function initUI(headers) {
            sheetHeaders = headers;
            cachedOptions = '<option value="">(Ignore)</option>';
            sheetHeaders.forEach((h) => {
               cachedOptions += \`<option value="\${h}">\${h}</option>\`; 
            });
            const container = document.getElementById('mappingContainer');
            container.innerHTML = '';
            mappingCount = 0;
            for(let i=0; i<5; i++) addMappingRow();
            if(sheetHeaders.length > 0) {
               const nameHeader = sheetHeaders.find(h => h.toLowerCase().includes('name') || h.toLowerCase().includes('id'));
               if(nameHeader) {
                 const firstSelect = document.getElementById('map_0');
                 if(firstSelect) firstSelect.value = nameHeader;
               }
            }
            const sel = document.getElementById('columnSelect');
            sel.innerHTML = '<option value="END">Create at the very end</option>';
            headers.forEach(h => {
              if(h) {
                const opt = document.createElement('option');
                opt.value = h;
                opt.innerText = 'After: ' + h;
                sel.appendChild(opt);
              }
            });
          }

          function addMappingRow() {
            const container = document.getElementById('mappingContainer');
            const i = mappingCount;
            let labelText = (i+1) + "th Item";
            if(i===0) labelText = "1st Item";
            else if(i===1) labelText = "2nd Item";
            else if(i===2) labelText = "3rd Item";
            const div = document.createElement('div');
            div.className = 'map-row';
            div.innerHTML = \`
              <div class="map-label">\${labelText}</div>
              <select id="map_\${i}" class="map-select">\${cachedOptions}</select>
            \`;
            container.appendChild(div);
            mappingCount++;
          }

          async function handleFile() {
             const input = document.getElementById('fileInput');
             const file = input.files[0];
             if(!file) return;
             showStatus("Reading file...", "none");
             document.getElementById('statusBox').style.display = 'block';
             document.getElementById('statusBox').innerText = "Reading file...";
             try {
               const data = await file.arrayBuffer();
               const workbook = XLSX.read(data);
               const firstSheetName = workbook.SheetNames[0];
               const worksheet = workbook.Sheets[firstSheetName];
               const json = XLSX.utils.sheet_to_json(worksheet, {header: 1, defval: ""});
               if(json.length === 0) throw new Error("File appears empty");
               const tsv = json.map(row => row.join('\\t')).join('\\n');
               document.getElementById('pasteArea').value = tsv;
               showStatus("File loaded! Review data in textarea.", "success");
             } catch(e) {
               showStatus("Error reading file: " + e.message, "error");
             }
          }

          function dedupeInput() {
            const area = document.getElementById('pasteArea');
            const raw = area.value;
            if(!raw.trim()) return showStatus("Input box is empty.", "error");
            const lines = raw.split(/\\n/);
            const uniqueSet = new Set();
            const cleanLines = [];
            let duplicateCount = 0;
            lines.forEach(line => {
              const trimmed = line.trim();
              if(!trimmed) return;
              const delim = trimmed.includes('\\t') ? '\\t' : ',';
              const key = trimmed.split(delim)[0].trim().toLowerCase();
              if(uniqueSet.has(key)) {
                duplicateCount++;
              } else {
                uniqueSet.add(key);
                cleanLines.push(trimmed);
              }
            });
            area.value = cleanLines.join('\\n');
            if(duplicateCount > 0) showStatus("Removed " + duplicateCount + " duplicates from input.", "success");
            else showStatus("No duplicates found in input.", "success");
          }

          function runSheetDedupe() {
            if(!confirm("Remove duplicates from Sheet based on Name/ID?")) return;
            const btn = document.getElementById('sheetDedupeBtn');
            btn.disabled = true;
            btn.innerText = "Cleaning...";
            google.script.run
              .withSuccessHandler(res => {
                btn.disabled = false;
                btn.innerText = "‚ö† Remove Duplicates from Sheet";
                showStatus(res, "success");
                loadHeaders();
              })
              .withFailureHandler(err => {
                btn.disabled = false;
                btn.innerText = "‚ö† Remove Duplicates from Sheet";
                showStatus("Error: " + err.message, "error");
              })
              .removeSheetDuplicates();
          }

          function runProcess() {
            const text = document.getElementById('pasteArea').value;
            const date = document.getElementById('dateInput').value;
            const insertAfter = document.getElementById('columnSelect').value;
            const btn = document.getElementById('runBtn');

            if (!text.trim()) return showStatus("Paste data first!", "error");

            const mapping = [];
            let i = 0;
            while(document.getElementById('map_' + i)) {
               mapping.push(document.getElementById('map_' + i).value);
               i++;
            }

            if (!mapping[0]) return showStatus("Map the 1st Item (Name/ID).", "error");

            btn.disabled = true;
            btn.innerText = "Processing...";
            showStatus("", "none");

            google.script.run
              .withSuccessHandler(res => {
                btn.disabled = false;
                btn.innerText = "Merge & Mark 'P'";
                showStatus(res.message, res.success ? "success" : "error");
                if(res.success) {
                  document.getElementById('pasteArea').value = "";
                  document.getElementById('fileInput').value = "";
                  loadHeaders();
                }
              })
              .withFailureHandler(err => {
                btn.disabled = false;
                btn.innerText = "Try Again";
                showStatus(err.message, "error");
              })
              .handleAttendance(text, date, insertAfter, mapping);
          }

          function showStatus(msg, type) {
            const el = document.getElementById('statusBox');
            if (type === "none") { el.style.display = 'none'; return; }
            el.innerText = msg;
            el.className = 'status ' + type;
            el.style.display = 'block';
          }
        </script>
      </body>
    </html>
  `;
}

/** --- SERVER SIDE LOGIC --- */

// Helper to get all existing names for Autocomplete
function getReferenceSuggestions() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const lastCol = sheet.getLastColumn();
  if (lastCol === 0) return [];
  const headers = sheet.getRange(1, 1, 1, lastCol).getDisplayValues()[0];
  
  // Find Name and Reference columns
  const whitelist = ['name', 'student', 'reference', 'connected', 'devotee', 'father'];
  const indices = [];
  headers.forEach((h, i) => {
    if (whitelist.some(w => h.toLowerCase().includes(w))) indices.push(i);
  });
  
  if (indices.length === 0) return [];
  
  const data = sheet.getDataRange().getValues();
  const suggestions = new Set();
  
  for (let i = 1; i < data.length; i++) {
    indices.forEach(colIdx => {
      const val = String(data[i][colIdx]).trim();
      if (val && val.length > 2) suggestions.add(val);
    });
  }
  
  return Array.from(suggestions).sort();
}

function getSheetHeaders() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const lastCol = sheet.getLastColumn();
  if (lastCol === 0) return [];
  return sheet.getRange(1, 1, 1, lastCol).getDisplayValues()[0].map(h => h.trim());
}

function processExport(selectedHeaders) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const data = sheet.getDataRange().getDisplayValues();
  const allHeaders = data[0];
  const indices = [];
  selectedHeaders.forEach(h => {
    const idx = allHeaders.indexOf(h);
    if (idx !== -1) indices.push(idx);
  });
  let csv = selectedHeaders.map(h => `"${h}"`).join(",") + "\n";
  for (let i = 1; i < data.length; i++) {
    const row = [];
    indices.forEach(idx => {
      let val = data[i][idx].toString().replace(/"/g, '""'); 
      row.push(`"${val}"`);
    });
    csv += row.join(",") + "\n";
  }
  return csv;
}

function removeSheetDuplicates() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const data = sheet.getDataRange().getValues();
  if (data.length < 2) return "Sheet is empty.";
  const headers = data[0];
  const idKeywords = ['id', 'roll', 'enrollment', 'code', 'unique', 'name', 'email', 'mobile'];
  let idColIndex = -1;
  for(let keyword of idKeywords) {
    idColIndex = headers.findIndex(h => h.toString().toLowerCase().includes(keyword));
    if(idColIndex !== -1) break;
  }
  if (idColIndex === -1) idColIndex = 0;
  const seen = new Set();
  const newData = [headers]; 
  let duplicates = 0;
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const key = String(row[idColIndex]).trim().toLowerCase();
    if (key && !seen.has(key)) {
      seen.add(key);
      newData.push(row);
    } else if (key) {
      duplicates++;
    } else {
      newData.push(row);
    }
  }
  if (duplicates > 0) {
    sheet.clearContents();
    sheet.getRange(1, 1, newData.length, newData[0].length).setValues(newData);
    return `Cleaned up! Removed ${duplicates} duplicates.`;
  } else {
    return "No duplicates found in sheet.";
  }
}

function handleAttendance(rawText, dateStr, insertAfterHeader, mappingArray) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    let lastCol = sheet.getLastColumn();
    if (lastCol === 0) return { success: false, message: "Sheet empty. Add headers first." };
    let headers = sheet.getRange(1, 1, 1, lastCol).getDisplayValues()[0].map(h => h.trim());
    let dateColIndex = headers.indexOf(dateStr.trim());
    let sheetColIndex = -1;
    if (dateColIndex === -1) {
      if (insertAfterHeader === "END") {
        sheetColIndex = lastCol + 1;
      } else {
        const targetIndex = headers.indexOf(insertAfterHeader);
        if (targetIndex === -1) sheetColIndex = lastCol + 1;
        else {
          sheet.insertColumnAfter(targetIndex + 1);
          sheetColIndex = targetIndex + 2;
        }
      }
      const headerCell = sheet.getRange(1, sheetColIndex);
      headerCell.setNumberFormat("@");
      headerCell.setValue(dateStr);
      SpreadsheetApp.flush();
      lastCol = sheet.getLastColumn();
      headers = sheet.getRange(1, 1, 1, lastCol).getDisplayValues()[0].map(h => h.trim());
      dateColIndex = headers.indexOf(dateStr.trim());
      if (dateColIndex !== -1) sheetColIndex = dateColIndex + 1;
    } else {
      sheetColIndex = dateColIndex + 1;
    }
    if (sheetColIndex < 1) sheetColIndex = sheet.getLastColumn() + 1;
    const primaryKeyHeader = mappingArray[0];
    const primaryKeyIndex = headers.findIndex(h => h.toLowerCase() === primaryKeyHeader.toLowerCase());
    if (primaryKeyIndex === -1) return { success: false, message: "Mapped ID column '" + primaryKeyHeader + "' not found." };
    const mobileKeywords = ['mobile', 'phone', 'contact', 'cell'];
    let sheetMobileIndex = headers.findIndex(h => mobileKeywords.some(k => h.toLowerCase().includes(k)));
    let inputMobileIndex = -1;
    for(let m=0; m<mappingArray.length; m++) {
       if(mappingArray[m] && mobileKeywords.some(k => mappingArray[m].toLowerCase().includes(k))) {
         inputMobileIndex = m;
         break;
       }
    }
    const referenceKeywords = ['reference', 'connected', 'devotee', 'father', 'mother', 'guardian', 'spouse'];
    const referenceIndices = [];
    headers.forEach((h, idx) => {
      if (referenceKeywords.some(k => h.toLowerCase().includes(k))) referenceIndices.push(idx);
    });
    const unsafeKeywords = [...referenceKeywords];
    const safeIndices = [];
    headers.forEach((h, idx) => {
      if (!unsafeKeywords.some(bad => h.toLowerCase().includes(bad))) safeIndices.push(idx);
    });
    const dataRange = sheet.getDataRange().getValues();
    const sheetRows = []; 
    for (let i = 1; i < dataRange.length; i++) {
      const rowNum = i + 1;
      const primaryVal = String(dataRange[i][primaryKeyIndex]).trim().toLowerCase();
      let mobileVal = "";
      if (sheetMobileIndex !== -1) {
        mobileVal = String(dataRange[i][sheetMobileIndex]).replace(/\D/g, ''); 
      }
      let fuzzyText = "";
      safeIndices.forEach(colIdx => {
         const val = String(dataRange[i][colIdx]).trim().toLowerCase();
         if(val) fuzzyText += " " + val + " ";
      });
      let referenceText = "";
      referenceIndices.forEach(colIdx => {
         const val = String(dataRange[i][colIdx]).trim().toLowerCase();
         if(val) referenceText += " " + val;
      });
      sheetRows.push({
        row: rowNum,
        primary: primaryVal,
        mobile: mobileVal,
        fuzzy: fuzzyText,
        reference: referenceText.trim()
      });
    }
    const rows = rawText.split(/\n/).map(r => r.trim()).filter(r => r !== "");
    let marked = 0, newAdded = 0;
    rows.forEach(line => {
      let parts;
      if (line.includes('\t')) parts = line.split('\t').map(s => s.trim());
      else parts = line.split(',').map(s => s.trim());
      const inputName = parts[0].toLowerCase();
      if (!inputName) return;
      let inputMobile = "";
      if (inputMobileIndex !== -1 && parts.length > inputMobileIndex) {
         inputMobile = String(parts[inputMobileIndex]).replace(/\D/g, '');
      }
      if (inputMobile.length < 10) {
         for (const part of parts) {
            const temp = part.replace(/\D/g, '');
            if (temp.length >= 10) {
               inputMobile = temp;
               break;
            }
         }
      }
      const inputTokens = inputName.split(/\s+/).filter(w => w.length > 2);
      const inputFullText = parts.join(" ").toLowerCase(); 
      const candidates = [];
      sheetRows.forEach(row => {
        let score = 0;
        let nameScore = 0;
        if (inputMobile.length >= 10 && row.mobile.length >= 10) {
           if (row.mobile.includes(inputMobile) || inputMobile.includes(row.mobile)) {
             score += 100;
           }
        }
        if (row.primary === inputName) {
           score += 50;
           nameScore = 50;
        } else {
           let tokenMatch = false;
           for (const token of inputTokens) {
              if (row.fuzzy.includes(token)) {
                 tokenMatch = true;
                 break;
              }
           }
           if (tokenMatch) {
              score += 20;
              nameScore = 20;
           }
        }
        if (row.reference && row.reference.length > 2) {
           const refWords = row.reference.split(/\s+/);
           for (const word of refWords) {
             if (word.length > 2 && inputFullText.includes(word)) {
               score += 25;
               break;
             }
           }
        }
        if (score > 0) {
           candidates.push({ row: row.row, score: score, nameScore: nameScore });
        }
      });
      let rowNum = null;
      if (candidates.length > 0) {
         candidates.sort((a,b) => b.score - a.score);
         const best = candidates[0];
         if (best.score >= 100) {
            if (best.nameScore > 0) {
               rowNum = best.row; 
            } else {
               const betterMatch = candidates.find(c => c.score >= 120); 
               if (betterMatch) {
                  rowNum = betterMatch.row;
               } else {
                  rowNum = null; 
               }
            }
         } else {
            const ties = candidates.filter(c => c.score === best.score);
            if (ties.length === 1 && best.score >= 20) {
               rowNum = best.row;
            } else {
               rowNum = null; 
            }
         }
      }
      if (rowNum) {
        sheet.getRange(rowNum, sheetColIndex).setValue("P");
        marked++;
        const currentRowVals = sheet.getRange(rowNum, 1, 1, headers.length).getValues()[0];
        for (let i = 1; i < parts.length; i++) {
           if (i >= mappingArray.length) break;
           const headerName = mappingArray[i];
           if (!headerName) continue;
           const colIdx = headers.findIndex(h => h.toLowerCase() === headerName.toLowerCase());
           if (colIdx !== -1) {
             if (!currentRowVals[colIdx] || currentRowVals[colIdx] === "") {
               sheet.getRange(rowNum, colIdx + 1).setValue(parts[i]);
             }
           }
        }
      } else {
        const nextRow = sheet.getLastRow() + 1;
        const newRowData = new Array(headers.length).fill("");
        for (let i = 0; i < parts.length; i++) {
           if (i >= mappingArray.length) break;
           const headerName = mappingArray[i];
           if (!headerName) continue;
           const colIdx = headers.findIndex(h => h.toLowerCase() === headerName.toLowerCase());
           if (colIdx !== -1) newRowData[colIdx] = parts[i];
        }
        if (dateColIndex < newRowData.length) newRowData[dateColIndex] = "P";
        else {
           while(newRowData.length <= dateColIndex) newRowData.push("");
           newRowData[dateColIndex] = "P";
        }
        const range = sheet.getRange(nextRow, 1, 1, newRowData.length);
        range.setValues([newRowData]);
        range.setFontColor("black");
        range.setBackground(null);
        range.setFontWeight("normal");
        sheetRows.push({ row: nextRow, primary: inputName, mobile: inputMobile, fuzzy: inputName, reference: "" });
        newAdded++;
      }
    });
    return { success: true, message: `Done! Marked: ${marked}, New: ${newAdded}` };
  } catch (e) {
    return { success: false, message: e.toString() };
  }
}
